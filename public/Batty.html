<!doctype html>
<html lang='en'>
  <head>
	  <title>Batty</title>
		<script src='js/modernizr.js'></script>
		<script src='js/pixi.dev.js'></script>
		<script>
		  (function(window) {
			
			  function DynamicBody(texture, world, options) {
				  var radians;
					
					PIXI.Sprite.apply(this, [texture]);
					
					this.world = world;
					
					// We use texture 'width' and 'height' instance properties rather then 'width' and 'height'
					// of 'this' variable in order to allow calling DynamicBody function without creating 
					// new object instance.
					this.width = this.width || texture.width;
					this.height = this.height || texture.height;
					this.position.x = options.x || this.width + 1;
					this.position.y = options.y || this.height + 1;
					this.vel = typeof (options.vel) !== 'undefined' ? options.vel : 15;
					this.angle = typeof (options.angle) !== 'undefined' ? options.angle : 30;
					this.stopAnimation = false;
					this.type = 'dynamic';
					
					radians = this.angle * Math.PI / 180;
					
					this.vx = Math.cos(radians) * this.vel;
					this.vy = Math.sin(radians) * this.vel;
				}
				
				DynamicBody.prototype = Object.create(PIXI.Sprite.prototype);
				DynamicBody.prototype.constructor = DynamicBody;
			
			  DynamicBody.prototype.updateTransform = function() {
					if (!this.stopAnimation) {
						var spritePosition = this.position,
								radians = this.angle * Math.PI / 180;
						
						PIXI.Sprite.prototype.updateTransform.call(this);
						
						this.vx = Math.cos(radians) * this.vel;
						this.vy = Math.sin(radians) * this.vel;
						
						spritePosition.x += this.vx;
						spritePosition.y += this.vy;
						
						if (this.onUpdateTransformed) {
							this.onUpdateTransformed();
						}
					}
				}
				
				DynamicBody.prototype.wallCollide = function() {
				  var spritePosition = this.position,
					    world = this.world;
					if (spritePosition.x + this.width > world.width) {
						this.angle = 180 - this.angle;
					  spritePosition.x = world.width - this.width;
					} else if (spritePosition.x < 0) {
						this.angle = 180 - this.angle;
					  spritePosition.x = 0;
					} else if (spritePosition.y < 0) {
					  this.angle = 360 - this.angle;
					  spritePosition.y = 0;
					} else if (this.visible && spritePosition.y > world.height) {
						if (this.onOutOfScreen) {
							this.onOutOfScreen(this);
						}
						return;
					}
					
					var radians = this.angle * Math.PI / 180;
					
					this.vx = this.vel * Math.cos(radians);
					this.vy = this.vel * Math.sin(radians);
				}
				
				DynamicBody.prototype.blocksCollide = function() {
				  var blocks = this.world.blocks,
					    blocksLength = blocks.length,
							block,
							i;
					
					for (i = 0; i < blocksLength; i++) {
					  block = blocks[i];
						if (block.visible && this.hitTestBlock(block)) {
							if (this.onBlockCollided) {
								this.onBlockCollided(block); 
							}
							
							break;
						}
					}
				}
				
				DynamicBody.prototype.hitTestBlock = function(block) {
				  var position = this.position,
					    isMissed;
					
					isMissed = position.x + this.width < block.position.x ||
						block.position.x + block.width < position.x ||
						position.y + this.height < block.position.y ||
						block.position.y + block.height < position.y;
					
					return !isMissed;
				}
				
				DynamicBody.prototype.blockCollide = function(block) {
				  var radians;
					
					var intersectionRect = this.getIntersectionRect(block);
					
					if (intersectionRect.width >= intersectionRect.height) {
						if (this.position.y >= block.position.y + block.height / 2) {
						  this.position.y = block.position.y + block.height;
						} else {
							this.position.y = block.position.y - this.height;
						}
						
						this.angle = 360 - this.angle;
					} else {
					  if (this.position.x < block.position.x) {
						  this.position.x = block.position.x - this.width;
						} else {
						  this.position.x = block.position.x + block.width;
						}
						
						this.angle = 180 - this.angle;
					}
					
					radians = this.angle * Math.PI / 180;
					
					this.vx = this.vel * Math.cos(radians);
					this.vy = this.vel * Math.sin(radians);
				}
				
				DynamicBody.prototype.getIntersectionRect = function(block) {
				  var height, width;
					
					var x11 = this.position.x,
							y11 = this.position.y,
							x12 = this.position.x + this.width,
							y12 = this.position.y + this.height,
							x21 = block.position.x,
							y21 = block.position.y,
							x22 = block.position.x + block.width,
							y22 = block.position.y + block.height;
					
					width = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
					height = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
					
					return { width: width, height: height };
				};
				
				DynamicBody.prototype.onUpdateTransformed = null;
				DynamicBody.prototype.onBlockCollided = null;
				DynamicBody.prototype.onOutOfScreen = null;
			
				function Circle(texture, world, options) {
					DynamicBody.apply(this, [texture, world, options]);
				}
				
				Circle.prototype = Object.create(DynamicBody.prototype);
				Circle.prototype.constructor = Circle;
				
				Circle.prototype.onUpdateTransformed = function(parent) {
				  this.wallCollide();
					this.blocksCollide();
				}
				
				Circle.prototype.onBlockCollided = function(block) {
					if (block.type === 'block' || block.type === 'slider') {
						this.blockCollide(block);
						
						// Potential memory leak issue cause block object cannot 
						// be disposed until gift object is disposed.
						if (block.type === 'block') {
							if (block.gift) {
								this.world.addGift(block.gift);
							}
							
							this.world.removeBlock(block);
						}
					}
				};
				
				Circle.prototype.onOutOfScreen = function(circle) {
					this.world.removeCircle(circle);
				};
				
				function Gift(textures, world, options) {
					var options = options || {};
					
					options.angle = options.angle || 90;
					
					DynamicBody.apply(this, [textures[0], world, options]);
					
					this.textures = textures;
					this.animationSpeed = options.animationSpeed || 1;
					this.loop = options.loop || true;
					this.onComplete = options.onComplete || null;
					this.currentFrame = options.currentFrame || 0;
					this.playing = options.playing || false;
				}
				
				Gift.prototype = (function() {
					var dynamicBodyPrototype = Object.create(DynamicBody.prototype),
							movieClipPrototype = Object.create(PIXI.MovieClip.prototype),
							giftPrototype = {},
							fnCopyProperties;
						
					fnCopyProperties = function(sourceObject, destObject) {
					  var prop;
						
						for (prop in sourceObject) {
						  destObject[prop] = sourceObject[prop];
						}
					};
					
					fnCopyProperties(dynamicBodyPrototype, giftPrototype);
					fnCopyProperties(movieClipPrototype, giftPrototype);
					
					// We want to override MovieClip's updateTransform method.
					giftPrototype.updateTransform = dynamicBodyPrototype.updateTransform;
					
					return giftPrototype;
				})();
				Gift.prototype.constructor = Gift;
				
				Gift.prototype.onUpdateTransformed = function() {
				  this.blocksCollide();
					PIXI.MovieClip.prototype.updateTransform.call(this);
				};
				
				Gift.prototype.onBlockCollided = function(block) {
				  if (block.type === 'slider') {
					  this.world.removeGift(this);
					}
				};
				
				function Slider(texture, world, options) {
				  var options = options || {};
					
					options.x = typeof (options.x) !== "undefined" ? options.x : world.width / 2 - texture.frame.width / 2;
					options.y = typeof (options.y) !== "undefined" ? options.y : world.height - texture.frame.height - 1;
					options.angle = 0;
					
					DynamicBody.apply(this, [texture, world, options]);
					
					this.vel1 = typeof (options.vel1) !== "undefined" ? options.vel1 : 15;
					this.type = 'slider';
					this.maxX = world.width - texture.frame.width;
					
					window.addEventListener('keydown', this.onKeyDown.bind(this));
					window.addEventListener('keyup', this.onKeyUp.bind(this));
				}
				
				Slider.prototype = Object.create(DynamicBody.prototype);
				Slider.prototype.constructor = Slider;
				
				Slider.prototype.onKeyDown = function(e) {
				  if (e.keyCode == 37) {
						this.vel = -this.vel1;
					} else if (e.keyCode == 39) {
						this.vel = this.vel1;
					}
				};
				
				Slider.prototype.onKeyUp = function(e) {
				  if (e.keyCode == 37 || e.keyCode == 39) {
						this.vel = 0;
					}
				};
				
				Slider.prototype.onUpdateTransformed = function() {
				  if (this.position.x < 0) {
					  this.position.x = 0;
					}	else if (this.position.x + this.width > this.world.width) {
					  this.position.x = this.world.width - this.width;
					}
				};
				
				function World(options) {
				  var x = 150,
							y = 150,
							world = this,
							blockImages = [ 'blue.png', 'purple.png', 'red.png', 'yellow.png' ],
							balls3GiftTexturesLength = 6,
							balls3GiftTextures = new Array(),
							circleTexture,
							blockTexture,
							circle,
							block,
							gift,
							i;
					
					this.width = options.width || 800;
					this.height = options.height || 600;
				  this.renderer = PIXI.autoDetectRenderer(this.width, this.height);
					this.stage = new PIXI.Stage(0xffffff);
					this.lostGame = false;
					this.wonGame = false;
					this.lostGameMessageShown = false;
					this.wonGameMessageShow = false;
					
					this.slider = new Slider(PIXI.TextureCache['slider.png'], this, { vel: 0, vel1: 25 });
					
					this.blocks = new Array();
					this.circles = new Array();
					this.gifts = new Array();
					
					for (i = 0; i < balls3GiftTexturesLength; i++) {
					  balls3GiftTextures.push(PIXI.TextureCache['3balls' + i + '.png']);
					}
					
					circleTexture = PIXI.TextureCache['ball.png'];
					
					if (!circleTexture) {
					  throw new Error('The frameId ' + ball.png + ' does not exist in the texture cache' + this);
					}
					
					for (i = 0; i < 5; i++) {
					  circle = new Circle(circleTexture, this, {
							x: 10 + Math.random() * this.width - 20,
							y: 10 + Math.random() * 100,
							vel: 0
						});
						
						this.circles.push(circle);
						this.stage.addChild(circle);
					}
					
					for (i = 0; i < 40; i++) {
					  blockTexture = PIXI.TextureCache[blockImages[i % blockImages.length]];
					
						if (!blockTexture) {
							throw new Error('The frameId ' + blockImages[i % blockImages.length] + ' does not exist in the texture cache ' + this);  
						}
					
					  block = new PIXI.Sprite(blockTexture);
						
						block.position.x = x + i % 8 * 55 + 1;
						block.position.y = y + Math.floor(i / 8) * 30;
						block.type = 'block';
						
						if (i % 10 == 0) {
							gift = new Gift(balls3GiftTextures, this, { x: block.position.x, y: block.position.y, vel: 1, animationSpeed: 0.1 });
							
							block.gift = gift;
						}
						
						this.stage.addChild(block);
						this.blocks.push(block);
					}
					
					this.stage.addChild(this.slider);
					this.blocks.push(this.slider);
					
					window.document.body.appendChild(this.renderer.view);
				}
				
				World.prototype.removeBlock = function(block) {
					this.removeBody(block, this.blocks);
				};
				
				World.prototype.addGift = function(gift) {
					gift.play();
					this.gifts.push(gift);
					this.stage.addChild(gift);
				};
				
				World.prototype.removeGift = function(gift) {
					var index = this.gifts.indexOf(gift);
					
					gift.visible = false;
					this.gifts.splice(index, 1);
				  //this.stage.removeChild(gift);
				};
				
				World.prototype.removeCircle = function(circle) {
				  this.removeBody(circle, this.circles);
				};
				
				World.prototype.removeBody = function(body, bodies) {
				  var index = bodies.indexOf(body);
					
					body.visible = false;
					bodies.splice(index, 1);
					
					//this.stage.removeChild(body);
				};
				
				World.prototype.stopAnimation = function() {
				  var childBodies = this.stage.children,
					    childBodiesLength = childBodies.length,
							i;
					
					for (i = 0; i < childBodiesLength; i++) {
					  if (childBodies[i].type === 'dynamic') {
						  childBodies[i].stopAnimation = true;
						}
					}
				};
				
				World.prototype.addMessage = function(message) {
				  var message = new PIXI.Text(message, {
					  font: 'bold 40px Arial',
						fill: '#0000ff'
					});
					
					message.anchor.x = 0.5;
					message.anchor.y = 0.5;
					
					message.position.x = this.width / 2;
					message.position.y = this.height / 2;
					
					this.stage.addChild(message);
				};
				
				World.prototype.draw = function() {
					if (!this.circles.length) {
						if (!this.lostGameMessageShown) {
							this.stopAnimation();
							this.lostGameMessageShown = true;
							this.addMessage('You lost!');
						}
					} else if (this.blocks.length == 1) {
						if (!this.wonGameMessageShown) {
							this.stopAnimation();
							this.wonGameMessageShown = true;
							this.addMessage('You won!');
						}
					}
							
					this.renderer.render(this.stage);
				}
				
				window.addEventListener('load', onWindowLoaded, false);
				
				function onWindowLoaded() {
				  var assets = ['SpriteSheet.json'],
							assetLoader;
					
					if (!Modernizr.canvas) {
					  return;
					}
					
					PIXI.dontSayHello = true;
					
					assetLoader = new PIXI.AssetLoader(assets);
					
					assetLoader.onComplete = function() {
					  var world = new World({ width: 800, height: 600 });
					
						gameLoop(world);
					};
					
					assetLoader.load();
				}
				
				function gameLoop(world) {
				  requestAnimFrame(function() {
						gameLoop(world);
					});
					
					world.draw();
				}
				
			})(window);
		</script>
	</head>
	<body>
	</body>
</html>