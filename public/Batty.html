<!doctype html>
<html lang="en">
  <head>
	  <title>Batty</title>
		<script src="js/modernizr.js"></script>
		<script src="js/pixi.dev.js"></script>
		<script>
		  (function(window) {
			
				function Circle(texture, world, options) {
				  var radians;
					
					PIXI.Sprite.apply(this, [texture]);
					
					this.world = world;
					this.type = "dynamic";
					
					this.position.x = options.x || 0;
					this.position.y = options.y || 0;
					this.vel = options.vel || 10;
					this.angle = options.angle || 30;
					
					radians = this.angle * Math.PI / 180;
					
					this.vx = Math.cos(radians) * this.vel;
					this.vy = Math.sin(radians) * this.vel;
				}
				
				Circle.prototype = Object.create(PIXI.Sprite.prototype);
				Circle.prototype.constructor = Circle;
				
				Circle.prototype.updatePosition = function() {
				  var spritePosition = this.position;
				
				  spritePosition.x += this.vx;
					spritePosition.y += this.vy;
					
					this.wallCollide();
					
					if (this.isOutOfScreen) {
					  this.world.removeCircle(this);
					} else {
					  this.blocksCollide();
					}
				}
				
				Circle.prototype.wallCollide = function() {
				  var spritePosition = this.position,
					    world = this.world;
					if (spritePosition.x + this.width > world.width) {
						this.angle = 180 - this.angle;
					  spritePosition.x = world.width - this.width;
					} else if (spritePosition.x < 0) {
						this.angle = 180 - this.angle;
					  spritePosition.x = 0;
					} else if (spritePosition.y < 0) {
					  this.angle = 360 - this.angle;
					  spritePosition.y = 0;
					}
					
					var radians = this.angle * Math.PI / 180;
					
					this.vx = this.vel * Math.cos(radians);
					this.vy = this.vel * Math.sin(radians);
				}
				
				Circle.prototype.blocksCollide = function() {
				  var blocks = this.world.blocks,
					    blocksLength = blocks.length,
							i;
					
					for (i = 0; i < blocksLength; i++) {
					  if (this.hitTestBlock(blocks[i])) {
							this.blockCollide(blocks[i]);
							if (blocks[i].type !== "slider") {
								this.world.removeBlock(blocks[i]);
								break;
							}
						}
					}
				}
				
				Circle.prototype.hitTestBlock = function(block) {
				  var position = this.position,
					    isMissed;
					
					isMissed = position.x + this.width < block.position.x ||
						block.position.x + block.width < position.x ||
						position.y + this.height < block.position.y ||
						block.position.y + block.height < position.y;
					
					return !isMissed;
				}
				
				Circle.prototype.blockCollide = function(block) {
				  var radians;
					
					var intersectionRect = this.getIntersectionRect(block);
					
					if (intersectionRect.width >= intersectionRect.height) {
						// We add 2 to because ball image frame y coordinate doesn't start at 
						// position 0.
					  if (this.position.y + 2 >= block.position.y + block.height) {
						  this.position.y = block.position.y + block.height;
						} else {
							this.position.y = block.position.y - this.height;
						}
						
						this.angle = 360 - this.angle;
					} else {
					  if (this.position.x < block.position.x) {
						  this.position.x = block.position.x - this.width;
						} else {
						  this.position.x = block.position.x + block.width;
						}
						
						this.angle = 180 - this.angle;
					}
					
					radians = this.angle * Math.PI / 180;
					
					this.vx = this.vel * Math.cos(radians);
					this.vy = this.vel * Math.sin(radians);
				}
				
				Circle.prototype.getIntersectionRect = function(block) {
				  var height, width;
					
					var x11 = this.position.x,
							y11 = this.position.y,
							x12 = this.position.x + this.width,
							y12 = this.position.y + this.height,
							x21 = block.position.x,
							y21 = block.position.y,
							x22 = block.position.x + block.width,
							y22 = block.position.y + block.height;
					
					width = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
					height = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
					
					return { width: width, height: height };
				};
				
				function World(options) {
				  var i = 0, 
					    x = 150,
							y = 200,
							world = this,
							circleTexture,
							blockTexture,
							circle,
							block;
					
					this.width = options.width || 800;
					this.height = options.height || 600;
				  this.renderer = PIXI.autoDetectRenderer(this.width, this.height);
					this.stage = new PIXI.Stage(0xffffff);
					this.lostGame = false;
					this.wonGame = false;
					this.lostGameMessageShown = false;
					this.wonGameMessageShow = false;
					
					this.slider = PIXI.Sprite.fromFrame("slider.png");
					this.slider.position.x = this.width / 2 - this.slider.width / 2;
					this.slider.position.y = this.height - this.slider.height - 1;
					this.slider.type = "slider";
					
					this.blocks = new Array();
					this.circles = new Array();
					
					circleTexture = PIXI.TextureCache["ball.png"];
					
					if (!circleTexture) {
					  throw new Error('The frameId "ball.png" does not exist in the texture cache' + this);
					}
					
					blockTexture = PIXI.TextureCache["red.png"];
					
					if (!blockTexture) {
					  throw new Error('The frameId "ball.png" does not exist in the texture cache' + this);  
					}
					
					for (i = 0; i < 10; i++) {
					  circle = new Circle(circleTexture, this, {
							x: 10 + Math.random() * this.width - 20,
							y: 10 + Math.random() * 100,
							vel: 15,
							radius: 10
						});
						
						this.circles.push(circle);
						this.stage.addChild(circle);
					}
					
					for (i = 0; i < 100; i++) {
						block = new PIXI.Sprite(blockTexture);
						
						block.position.x = x + i % 20 * 60 + 1;
						block.position.y = y + Math.floor(i / 20) * 25;
						
						this.stage.addChild(block);
						this.blocks.push(block);
					}
					
					this.stage.addChild(this.slider);
					this.blocks.push(this.slider);
					
					window.addEventListener("keydown", function(e) {
						if (e.keyCode == 37) {
							world.moveSlider(-30);
						} else if (e.keyCode == 39) {
						  world.moveSlider(30);
						}
					});
					
					window.addEventListener("keyup", function(e) {
						if (e.keyCode == 37 || e.keyCode == 39) {
						  world.moveSlider(0);
						}
					});
					
					window.document.body.appendChild(this.renderer.view);
				}
				
				World.prototype.removeOutOfScreenCircles = function() {
				  var circlesLength = this.circles.length,
					    i;
					
					for (i = 0; i < circlesLength; i++) {
						if (this.circles[i].position.y > this.height) {
							this.circles.splice(i, 1);
							i--; 
							circlesLength--;
						}
					}
				};
				
				World.prototype.removeBlock = function(block) {
				  var index = this.blocks.indexOf(block);
					
					this.blocks.splice(index, 1);
					this.stage.removeChild(block);
				};
				
				World.prototype.moveSlider = function(sliderIncrease) {
				  this.sliderIncrease = sliderIncrease;
				};
				
				World.prototype.drawBackground = function() {
					var context = this.context,
						  canvasWidth = context.canvas.width,
							canvasHeight = context.canvas.height;
					
					context.fillStyle = "#ffffff";
					context.fillRect(0, 0, canvasWidth, canvasHeight);
					
					radialGradient = context.createRadialGradient(
						canvasWidth, canvasWidth, canvasWidth, 
						canvasWidth, canvasWidth, canvasWidth + 1);
						
					radialGradient.addColorStop(0, "rgb(230, 230, 252)");
					radialGradient.addColorStop(1, "rgb(177, 177, 222)");
					
					context.fillStyle = radialGradient;
					context.fillRect(0, 0, canvasWidth, canvasHeight);	
				};
				
				World.prototype.addMessage = function(message) {
				  var message = new PIXI.Text(message, {
					  font: "bold 40px Arial",
						fill: "#0000ff"
					});
					
					message.anchor.x = 0.5;
					message.anchor.y = 0.5;
					
					message.position.x = this.width / 2;
					message.position.y = this.height / 2;
					
					this.stage.addChild(message);
				};
				
				World.prototype.updateCirclesPositions = function() {
					var circlesLength = this.circles.length,
					    i;
								
					for (i = 0; i < circlesLength; i++) {
						this.circles[i].updatePosition();
					}
				};
				
				World.prototype.updateSliderPosition = function() {
				  if (this.sliderIncrease < 0 && this.slider.position.x + this.sliderIncrease >= 0) {
						this.slider.position.x += this.sliderIncrease;
					} else if (this.sliderIncrease > 0 && 
						this.slider.position.x + this.slider.width + this.sliderIncrease <= this.width) {
						this.slider.position.x += this.sliderIncrease;
					}
				};
				
				World.prototype.draw = function() {
					if (!this.circles.length) {
						if (!this.lostGameMessageShown) {
							this.lostGameMessageShown = true;
							this.addMessage("You lost!");
						}
					} else if (this.blocks.length == 1) {
						if (!this.wonGameMessageShown) {
							this.wonGameMessageShown = true;
							this.addMessage("You won!");
						}
					} else {
						this.updateCirclesPositions();
						this.removeOutOfScreenCircles();
						
						if (this.sliderIncrease) {
							this.updateSliderPosition();
						}
					}						
							
					this.renderer.render(this.stage);
				}
				
				window.addEventListener("load", onWindowLoaded, false);
				
				function onWindowLoaded() {
				  var assets = ["SpriteSheet.json"],
							assetLoader;
					
					if (!Modernizr.canvas) {
					  return;
					}
					
					PIXI.dontSayHello = true;
					
					assetLoader = new PIXI.AssetLoader(assets);
					
					assetLoader.onComplete = function() {
					  var world = new World({ width: 1500, height: 900 });
					
						gameLoop(world);
					};
					
					assetLoader.load();
				}
				
				function gameLoop(world) {
				  requestAnimFrame(function() {
						gameLoop(world);
					});
					
					world.draw();
				}
				
			})(window);
		</script>
	</head>
	<body>
	</body>
</html>